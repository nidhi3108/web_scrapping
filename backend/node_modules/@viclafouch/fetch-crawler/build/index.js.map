{"version":3,"sources":["src/index.js"],"names":["Crawler","constructor","options","_options","Object","assign","maxRequest","skipStrictDuplicates","sameOrigin","maxDepth","parallel","debugging","retryCount","retryTimeout","timeBetweenRequest","hostdomain","linksToCrawl","Map","linksCrawled","_actions","preRequest","x","onSuccess","onError","evaluatePage","onRedirection","previousUrl","fetch","args","retries","_retry","controller","AbortController","timeout","setTimeout","abort","signal","then","e","clearTimeout","Promise","resolve","err","catch","error","name","message","init","url","Error","link","URL","origin","console","set","pull","size","crawl","collectAnchors","$","actualHref","linksCollected","map","i","attr","filter","href","hash","get","Set","skipRequest","allowOrigin","checkSameOrigin","urlSanitazed","shouldRequest","linkAlreadyCollected","Function","info","evaluate","result","addToQueue","urlCollected","depth","linkEdited","reject","canceled","currentCrawlers","pullQueue","checkMaxRequest","currentLink","keys","next","value","currentDepth","delete","wrongRedirection","scrapePage","scrapeError","urlScraped","scrapeSucceed","has","response","redirected","status","textResponse","text","cheerio","load","all","launch","startCrawlingAt","Date","crawler","finishCrawlingAt","linksVisited","module","exports"],"mappings":"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","sourceRoot":"..","sourcesContent":["import AbortController from 'abort-controller'\nimport { URL } from 'url'\nimport { isUrl, relativePath } from './utils'\nimport fetch from 'node-fetch'\nimport cheerio from 'cheerio'\n\nclass Crawler {\n  constructor(options = {}) {\n    this._options = Object.assign(\n      {},\n      {\n        maxRequest: -1,\n        skipStrictDuplicates: true,\n        sameOrigin: true,\n        maxDepth: 3,\n        parallel: 5,\n        debugging: false,\n        retryCount: 2,\n        retryTimeout: 5000,\n        timeBetweenRequest: 0\n      },\n      options\n    )\n    if (this._options.timeBetweenRequest > 0) this._options.parallel = 1\n    this.hostdomain = ''\n    this.linksToCrawl = new Map()\n    this.linksCrawled = new Map()\n    this._actions = {\n      preRequest: this._options.preRequest || (x => x),\n      onSuccess: this._options.onSuccess || null,\n      onError: this._options.onError || null,\n      evaluatePage: this._options.evaluatePage || null,\n      onRedirection: this._options.onRedirection || (({ previousUrl }) => previousUrl)\n    }\n  }\n\n  fetch(...args) {\n    let retries = 0\n    const _retry = () => {\n      const controller = new AbortController()\n      const timeout = setTimeout(() => controller.abort(), this._options.retryTimeout)\n      return fetch(...args, { signal: controller.signal })\n        .then(\n          e => {\n            clearTimeout(timeout)\n            return Promise.resolve(e)\n          },\n          err => {\n            throw err\n          }\n        )\n        .catch(error => {\n          clearTimeout(timeout)\n          if (retries < this._options.retryCount) {\n            retries++\n            return _retry(...args)\n          } else {\n            if (error.name === 'AbortError') {\n              error.message = `Request canceled (timeout = ${this._options.retryTimeout}ms)`\n            }\n            throw error\n          }\n        })\n    }\n    return _retry()\n  }\n\n  /**\n   * Init the app.\n   * Begin with the first link, and start the pulling\n   * @return {Promise<pending>}\n   */\n  async init() {\n    try {\n      if (!isUrl(this._options.url)) throw new Error()\n      const link = new URL(this._options.url)\n      this.hostdomain = link.origin\n      if (!this.hostdomain) throw new Error()\n    } catch (error) {\n      console.error(error)\n      throw new Error('URL provided (' + this._options.url + ') is not valid')\n    }\n\n    this.linksCrawled.set(this._options.url)\n    await this.pull(this._options.url, 1)\n    if (this.linksToCrawl.size > 0) await this.crawl()\n  }\n\n  /**\n   * Get all links from the page.\n   * @param {Cheerio} $\n   * @param {String} actualHref\n   * @return {Promise<Array<String>}\n   */\n  collectAnchors($, actualHref) {\n    let linksCollected = []\n    try {\n      linksCollected = $('a')\n        .map((i, e) => relativePath($(e).attr('href') || '', actualHref)) // Cheerio map method\n        .filter((i, href) => isUrl(href)) // Cheerio filter method\n        .map((i, href) => {\n          const url = new URL(href)\n          url.hash = ''\n          return url.href\n        })\n        .get() // Cheerio get method to transform as an array\n    } catch (error) {\n      console.error(`Something wrong happened with this url: ${actualHref}`)\n      console.error(error)\n    }\n    return [...new Set(linksCollected)] // Avoid duplication\n  }\n\n  /**\n   * Check if link can be crawled (Same origin ? Already collected ? preRequest !false ?).\n   * @param {String} link\n   * @return {Promise<Boolean>}\n   */\n  async skipRequest(link) {\n    const allowOrigin = this.checkSameOrigin(link)\n    if (!allowOrigin) return true\n    const urlSanitazed = await this.shouldRequest(link)\n    if (!urlSanitazed) return true\n    if (this._options.skipStrictDuplicates && this.linkAlreadyCollected(urlSanitazed)) return true\n    return false\n  }\n\n  /**\n   * If preRequest is provided by the user, get new link or false.\n   * @param {String} link\n   * @return {Promise<String || Boolean>}\n   */\n  async shouldRequest(link) {\n    if (this._actions.preRequest instanceof Function) {\n      try {\n        const preRequest = await this._actions.preRequest(link)\n        if (preRequest === false && this._options.debugging) console.info(`\\x1b[33m Ignoring ${link} \\x1b[m`)\n        if (typeof preRequest === 'string' || preRequest === false) return preRequest\n        throw new Error('preRequest function must return a String or False')\n      } catch (error) {\n        console.error('Please try/catch your preRequest function')\n        console.error(error.message)\n      }\n    }\n    return link\n  }\n\n  /**\n   * Check if link has the same origin as the host link.\n   * @param {String} url\n   * @return {Boolean}\n   */\n  checkSameOrigin(url) {\n    if (this._options.sameOrigin) return new URL(url).origin === this.hostdomain\n    return true\n  }\n\n  /**\n   * If evaluatePage is provided by the user, await for it.\n   * @param {Cheerio} $\n   * @return {Promise}\n   */\n  async evaluate($) {\n    let result = null\n    if (this._actions.evaluatePage && this._actions.evaluatePage instanceof Function) {\n      try {\n        result = await this._actions.evaluatePage($)\n      } catch (error) {\n        console.error('Please try/catch your evaluatePage function')\n        console.error(error)\n      }\n    }\n    return result\n  }\n\n  /**\n   * Add links collected to queue.\n   * @param {Array<String>} urlCollected\n   * @param {Number} depth\n   * @return {Promise}\n   */\n  async addToQueue(urlCollected, depth = 0) {\n    for (const url of urlCollected) {\n      if (depth <= this._options.maxDepth) {\n        if (!(await this.skipRequest(url))) {\n          const linkEdited = await this.shouldRequest(url)\n          this.linksToCrawl.set(linkEdited, depth)\n        }\n      }\n    }\n  }\n\n  /**\n   * Crawl links from 'linksToCrawl' and wait for having 'canceled' to true.\n   * @return {Promise>}\n   */\n  crawl() {\n    return new Promise((resolve, reject) => {\n      let canceled = false\n      let currentCrawlers = 0\n      const pullQueue = () => {\n        if (canceled) return\n        while (currentCrawlers < this._options.parallel && this.linksToCrawl.size > 0) {\n          canceled = !this.checkMaxRequest()\n          if (canceled) {\n            currentCrawlers === 0 && resolve()\n            break\n          }\n          currentCrawlers++\n          const currentLink = this.linksToCrawl.keys().next().value\n          const currentDepth = this.linksToCrawl.get(currentLink)\n          this.linksToCrawl.delete(currentLink)\n          this.linksCrawled.set(currentLink)\n          this.pull(currentLink, currentDepth)\n            .then(() => {\n              currentCrawlers--\n              if (currentCrawlers === 0 && (this.linksToCrawl.size === 0 || canceled)) resolve()\n              else pullQueue()\n            })\n            .catch(error => {\n              canceled = true\n              reject(error)\n            })\n        }\n      }\n      pullQueue()\n    })\n  }\n\n  /**\n   * Pull result and links from a page and add them to the queue.\n   * @param {String} link\n   * @param {Number} depth\n   * @return {Promise<pending>}\n   */\n  async pull(link, depth) {\n    if (this._options.timeBetweenRequest) await new Promise(resolve => setTimeout(resolve, this._options.timeBetweenRequest))\n    this._options.debugging &&\n      console.info(\n        `\\x1b[1;32m [${this.linksCrawled.size}${\n          this._options.maxRequest !== -1 ? '/' + this._options.maxRequest : ''\n        }] Crawling ${link} ...\\x1b[m`\n      )\n    const { result, linksCollected, url, wrongRedirection, error } = await this.scrapePage(link)\n    if (error) {\n      await this.scrapeError({ urlScraped: url, error })\n    } else if (!wrongRedirection) {\n      await this.scrapeSucceed({ urlScraped: url, result })\n      await this.addToQueue(linksCollected, depth + 1)\n    }\n  }\n\n  /**\n   * Know if a link will be crawled or has already been crawled.\n   * @param {String} url\n   * @return {Boolean}\n   */\n  linkAlreadyCollected(url) {\n    return this.linksCrawled.has(url) || this.linksToCrawl.has(url)\n  }\n\n  /**\n   * Know if we have exceeded the number of request max provided in the options.\n   * @return {Boolean}\n   */\n  checkMaxRequest() {\n    if (this._options.maxRequest === -1) return true\n    return this.linksCrawled.size < this._options.maxRequest\n  }\n\n  /**\n   * If onSuccess action's has been provided, await for it.\n   * @param {Object<{urlScraped: string, result: any}>}\n   * @return {Promise<pending>}\n   */\n  async scrapeSucceed({ urlScraped, result }) {\n    if (this._actions.onSuccess && this._actions.onSuccess instanceof Function) {\n      try {\n        await this._actions.onSuccess({ result, url: urlScraped })\n      } catch (error) {\n        console.error('Please try/catch your onSuccess function')\n      }\n    }\n  }\n\n  /**\n   * If onError action's has been provided, await for it.\n   * @param {Object<{urlScraped: string, error: Error}>}\n   * @return {Promise<pending>}\n   */\n  async scrapeError({ urlScraped, error }) {\n    if (this._actions.onError && this._actions.onError instanceof Function) {\n      try {\n        await this._actions.onError({ error, url: urlScraped })\n      } catch (error) {\n        console.error('Please try/catch your onError function')\n      }\n    }\n  }\n\n  /**\n   * Scrap a page, evaluate and get new links to visit.\n   * @param {String} url\n   * @return {Promise<{linksCollected: array, result: any, url: string}>}\n   */\n  async scrapePage(url) {\n    try {\n      const response = await this.fetch(url)\n      if (response.redirected) {\n        url = await this._options.onRedirection({ previousUrl: url, response })\n        if (!url)\n          return {\n            wrongRedirection: true\n          }\n      } else if (response.status !== 200) throw response\n      const textResponse = await response.text()\n      const $ = cheerio.load(textResponse)\n      const [result, linksCollected] = await Promise.all([this.evaluate($), this.collectAnchors($, url)])\n      return { linksCollected, result, url }\n    } catch (error) {\n      return { url, error }\n    }\n  }\n\n  /**\n   * Starting the crawl.\n   * @param {{debugging: Boolean, maxRequest: Number, parallel: Number, maxDepth: Number, sameOrigin: Boolean, skipStrictDuplicates: Boolean, retryCount: Number, retryTimeout: Number, timeBetweenRequest: Number }} options Options of the crawler.\n   * @return {Promise<{startCrawlingAt: Date, finishCrawlingAt: Date, linksVisited: Number}>}\n   */\n  static async launch(options) {\n    const startCrawlingAt = new Date()\n    const crawler = new Crawler(options)\n    await crawler.init()\n    const finishCrawlingAt = new Date()\n    return { startCrawlingAt, finishCrawlingAt, linksVisited: crawler.linksCrawled.size }\n  }\n}\n\nmodule.exports = Crawler\n"],"file":"index.js"}